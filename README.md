# [프로젝트 이름]

> STAY(스테이) 실시간 주차 위치 파악 및 사용자의 피로도를 낮춘 방문 차량 관리

## 1. 프로젝트 소개

- **설명:** 기획부터 디자인, 개발까지 직접 참여하였으며, 입주민·사업자·관리자 역할 기반 UI와 주차 현황 확인 및 차량 등록 기능을 중심으로 한 주차 관리 시스템 프로젝트입니다. Supabase를 활용하여 방문 차량 등록, 장기 차량 관리 등 실제 서비스 흐름을 구현하였습니다.
- **진행 기간:** 2025.01.02 ~ 2025.01.13 (12일)
- **개발 인원:** FrontEnd 5인 (Team Project)
- **배포 링크:** [(https://github.com/sseunghui614-commits/stay.git)]

## 2. 사용 기술 스택 (Tech Stack)

- **Language:** JavaScript (ES6+)
- **Framework:** React.js
- **Styling:** SCSS
- **Data Handling:** Custom Mock Data (JSON)
- **Design & Tool:** **Figma** Photoshop, Illustrator, Git, GitHub, GSAP, Sass, Supabase

## 3. 기획 및 디자인 (Planning & Design)

- **Tool:** Figma
- **Concept:** 사용자 직관성을 고려한 UI/UX 설계 및 와이어프레임 제작

## 4. 디렉토리 구조

```text
src
├── api             # Supabase 기반으로 관리자, 사용자, 주차, 정산 등 주요 기능의 데이터 처리를 담당하는 API 모음
│   
├── assets          # 프로젝트 전반에서 공통으로 사용하는 리소스를 관리
│     │   
│     ├── images    # 페이지 각 섹션에 사용되는 이미지 파일을 관리
│     │   
│     ├── scss      # 공통 스타일 정의를 위한 색상 변수, 폰트 스타일, 반응형 및 레이아웃 mixin, 전역 스타일을 관리
│     │   
│     └── svg       # 페이지에 사용되는 SVG 아이콘 및 이미지 파일을 관리
│     
├── components      # 공통 UI 및 서비스 핵심 기능 컴포넌트를 관리
│     │    
│     ├── common    # 프로젝트 전반에서 공통으로 사용되는 UI 및 스크립트 컴포넌트를 관리
│     │   
│     └── mode      # 차량 등록, 할인권 발급 및 정산 등 주차장 관리 핵심 기능 컴포넌트를 관리
│     
├── contexts        # 사용자, 관리자, 주차 현황 등 도메인별 상태 관리
│
├── layout          # 공통 페이지 레이아웃 관리
│
└── pages           # 실제 보여지는 페이지 컴포넌트 관리

## 5. 담당 역할

[기획 및 디자인]
* Figma를 활용한 전체 와이어프레임 및 프로토타입 제작
* 공통 컬러 팔레트 및 컴포넌트 스타일 가이드 정립

[개발: Core 구조 + 페이지 담당]
1. 데이터 구조 및 DB 설계/관리 (전 페이지 공통, 실질 단독)
Supabase 기반 모든 페이지 기능에 필요한 테이블/컬럼 설계
사용자 유형(입주민/사업자/관리자) 및 방문 유형(일반/예약/장기) 기준으로 데이터 분기 구조 정의
즐겨찾기, 방문차량, 승인 상태 등 사용자 행동과 직결되는 데이터 흐름이 끊기지 않도록 정합성 중심으로 설계

2. API 레이어 구현 (/api)
Supabase 쿼리를 페이지에서 직접 호출하지 않도록 도메인 기준으로 API 분리
userApi / adminApi / parkingApi 형태로 역할과 책임을 구분
기능별로 필요한 쿼리/예외처리를 API 쪽에서 정리해 페이지 구현 부담을 줄임

3. Context 설계 및 구현 (/contexts)
UserContext / ParkingContext / AdminContext로 상태를 분리하고,
인증/권한/주차현황 등 전역 상태 흐름을 Context로 통일
팀원들이 페이지 구현 시 Context의 value만 가져다 쓰는 방식으로 연동 기준을 맞춤

4.직접 담당한 페이지
로그인 / 회원가입 페이지 UI 및 기능 구현  
사용자 상태를 고려한 로그인 접근 구조 설계  
로그인 성공 시 권한(role) 기반 라우팅 분기 처리

5.기능 연동 협업 지원
즐겨찾기/방문차량 페이지 담당자와 함께 연동 이슈 확인 및 수정
시연을 위한 seed 데이터 구성 및 SQL 파일 정리/공유
Control 페이지 입·출차 로직 수정 요청 반영(관련 함수 Context에 추가)



## 6. 주요 기능
Supabase 기반 전체 테이블/컬럼 설계 및 데이터 흐름 정의
역할 기반 서비스 구조
입주민/사업자/관리자 권한에 따른 접근 및 화면 분기
로그인/회원가입 구현
승인 대기(PENDING) 상태 분기 처리
API/Context 기반 공통 구조
페이지마다 다른 방식으로 구현되지 않도록 데이터 흐름 통일
시연 안정화 작업
즐겨찾기/방문차량/정산/사업자 방문기록 등 확인용 데이터 구성

## 7. 트러블 슈팅

[문제 0. 페이지별 데이터 기준 부재로 인한 협업 혼선]
(데이터 정의 공유 부족으로 발생한 구조적 문제)

<상황>
프로젝트 초반, 강사님께서 각 페이지를 구현하며 필요한 데이터를 DB 쪽에 전달한 뒤 API를 구성하는 흐름을 안내해주셨습니다.
그러나 실제 개발 과정에서는 각 페이지 구현이 동시에 진행되면서,
페이지별로 필요한 데이터 정의가 한 번에 정리·공유되기 어려운 상황이었습니다.
그 결과 공통 DB 기준 없이 페이지 구현이 선행되었고, 이후 기능 연동 단계에서
데이터 구조 불일치, 중복 데이터, 기능 동작 오류 등
여러 페이지에서 혼선이 발생할 가능성이 있는 상태였습니다.

<원인>
이상적인 협업 흐름은 페이지별 데이터 정의 → DB 설계 → API 구성 순서였으나,
병행 개발 과정에서 페이지별 데이터 요구사항이 충분히 공유되지 못하면서
공통으로 참조할 데이터 구조(DB)가 기준점 역할을 하지 못했던 구조적 한계가 
문제의 원인이었습니다.

<해결 / 과정>
기능 연동 단계에서 혼선이 커지기 전에, 공통 DB 구조를 기준으로 페이지 구현을 맞추는 방향이 제시되었고, 
해당 기준에 따라 개발 흐름을 정리했습니다.
이에 따라 페이지 구현에 필요한 데이터를 정리해 공통 DB 테이블을 우선 구성, 중복되거나 모호한 데이터 구조 정리
이후 각 페이지가 해당 DB 구조를 기준으로 기능을 수정·연결하는 방식으로 작업을 진행하는 흐름으로 협업 방향이 정리되었습니다.

<결과>
공통 DB 구조가 기준점 역할을 하게 되면서
페이지 간 데이터 불일치로 인한 혼선이 줄었고,
기능 연동과 이후 트러블 슈팅을
공통 기준 하에서 빠르게 정리할 수 있었습니다.


[문제 1. 즐겨찾기 토글이 정상적으로 동작하지 않고 400 에러가 발생하던 문제]
(데이터 중복으로 인한 기능 오류)

<상황>
같은 사용자가 동일한 차량을 여러 번 즐겨찾기할 경우 DB에 중복 데이터가 insert되면서 400 에러가 발생했고,
그로 인해 즐겨찾기 토글 해제가 정상적으로 동작하지 않았습니다.
UI 상에서는 버튼이 반응하지 않는 것처럼 보여 사용자 입장에서 혼란이 생길 수 있는 상황이었습니다.

<원인>
favorite_cars 테이블에 동일 사용자와 차량 조합에 대한 중복을 막는 제약 조건이 없어,
데이터 구조 단계에서 중복 케이스를 충분히 고려하지 못한 상태였습니다.

<해결 / 과정>
페이지 담당자와 상황을 공유한 뒤, profile_id와 car_num을 기준으로 한
복합 UNIQUE 제약을 테이블에 추가해 중복 데이터가 들어가지 않도록 수정했습니다.
또한 기능 확인이 수월하도록 예약 리스트에 있는 차량 번호를 활용해 즐겨찾기 테스트용 데이터를 함께 구성했습니다.

<결과>
즐겨찾기 토글 기능이 정상적으로 동작하게 되었고, 데이터 상태와 UI 동작이 어긋나던 문제가 해소되었습니다.
이후 동일한 방식의 중복 이슈는 발생하지 않았습니다.


[문제 2. 기획 변경으로 추가된 Control 페이지 입·출차 기능 연동 이슈]
(중간 기획 변경에 따른 API / Context 연결 문제)

<상황>
프로젝트 초반 기획에는 입·출차를 직접 제어하는 Control 페이지가 없었습니다.
시연을 준비하는 과정에서 입·출차 버튼이 필요해지면서 Control 페이지가 중간에 추가되었고,
기존 페이지 흐름과는 다른 방식으로 기능을 연결해야 하는 상황이 생겼습니다.
입·출차 기능 자체는 Control 페이지 담당자가 구현한 상태였으나, 
해당 기능들이 페이지 내부에서만 사용되고 있어
다른 화면들과 호출 기준이 서로 다른 구조였습니다.

<원인>
Control 페이지는 초기 설계에 없던 페이지였기 때문에
입·출차 기능이 기존 Context 구조와 자연스럽게 연결되지 않은 상태였습니다.
또한 입·출차 관련 함수들이 페이지 단위로 분리되어 있어, 공통된 기준 없이 개별적으로 호출되는 구조였습니다.

<해결 / 과정>
Control 페이지 담당자가 구현한 입·출차 관련 함수들을 ParkingContext에 import하고 value에 추가해,
페이지 간 동일한 기준으로 기능을 호출할 수 있도록 구조를 정리했습니다.
이를 통해 Control 페이지에서도 기존 페이지들과 동일하게 Context를 통해 기능을 사용할 수 있도록 연결했습니다.
실시간 반영이 어려운 부분에 대해서는 
시연 중 혼선을 줄이기 위해 재조회(새로고침) 방식으로 확인하는 흐름을
팀원들과 공유했습니다.

<결과>
중간에 추가된 Control 페이지에서도
기존 페이지들과 동일한 기준으로 입·출차 기능을 사용할 수 있게 되었고,
시연 과정에서 기능 흐름을 설명하고 확인하는 데 부담을 줄일 수 있었습니다.



## 8. 실행 화면
(구현한 화면 스크린샷 1장 첨부)
```
